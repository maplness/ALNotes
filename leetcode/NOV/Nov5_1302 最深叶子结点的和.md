# Nov5_1302 最深叶子结点的和
![](https://tva1.sinaimg.cn/large/0081Kckwgy1gkervvh2i2j30ni0tsad3.jpg)

一次层次遍历 ， 用sum记录每一层的和，每一层覆盖，最后返回sum。用queue.size()控制层数。

``` C++
class Solution {
public:
	int deepestLeavesSum(TreeNode* root) {
		if(!root) return 0;
		queue<TreeNode *> q;
		q.push(root);
		int sum = 0;
		while(!q.empty()){
			sum = 0;
			int size = q.size();
			for(int i = 0 ; i < q.size() ; i++){
				TreeNode *cur = q.front();
				q.pop();
				sum+=cur->val;
				if(cur->left) q.push(cur->left);
				if(cur->right) q.push(cur->right);
				
			}
		}
		return sum;
	}
};
```
